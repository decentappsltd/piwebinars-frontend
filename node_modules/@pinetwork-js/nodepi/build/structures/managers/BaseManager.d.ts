import { Client } from '../../clients';
import { Identifiable, Patchable } from '../interfaces';
export declare function isPatchable(entry: Record<PropertyKey, any>): entry is Patchable;
export interface BaseManager<H, D, E, V, K> {
    /**
     * Fetches the data from Pi Network APIs (or return the cached element, if `cache` is true).
     *
     * @param key - The data's key (id, etc.).
     * @param cache - If the data should be cached (or cached data patched), `true` by default.
     * @param checkCache - If the cached data should be returned (if it exists) rather than fetching the data, `true` by default.
     * @returns The the fetched (or cached) data, or `undefined` if not found.
     */
    fetch?(key: K, cache?: boolean, checkCache?: boolean): Promise<V | undefined>;
}
export declare abstract class BaseManager<H extends new (client: Client, data: any, ...args: any[]) => Identifiable<K>, D = H extends new (client: Client, data: infer R, ...args: any[]) => any ? R : never, E = H extends new (client: Client, data: any, ...args: infer R) => any ? R : never, V = H extends new (client: Client, data: any, ...args: any[]) => infer R ? R : never, K = V extends Identifiable<infer R> ? R : never> {
    readonly client: Client;
    protected readonly hold: H;
    protected readonly extras?: E | undefined;
    /**
     * The cache of the manager.
     */
    readonly cache: Map<K, V>;
    constructor(client: Client, hold: H, iterable?: (D | V)[], extras?: E | undefined);
    /**
     * Adds the data to the cache (or return the cached element, if `cache` is true).
     *
     * @param data - The data to add.
     * @param cache - If the data should be cached (or cached data patched), `true` by default.
     * @returns The resolved data.
     */
    abstract add(data: D | V, cache: boolean): V;
    /**
     * Resolves the data by its key from the cache.
     *
     * @param key - The data's key (id, etc.).
     * @returns The cached data or `undefined` if not found.
     */
    resolve(key: K): V | undefined;
}
