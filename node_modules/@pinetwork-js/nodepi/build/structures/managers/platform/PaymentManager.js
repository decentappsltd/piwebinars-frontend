"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentManager = void 0;
const api_typing_1 = require("@pinetwork-js/api-typing");
const ressources_1 = require("../../ressources");
const BaseManager_1 = require("../BaseManager");
class PaymentManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super(client, ressources_1.Payment);
    }
    /**
     * Adds the payment to the cache (or return the cached payment, if `cache` is true).
     *
     * @param data - The payment to add.
     * @param cache - If the payment should be cached (or cached payment patched), `true` by default.
     * @returns The resolved payment.
     */
    add(data, cache = true) {
        const existing = this.cache.get(data.identifier);
        if (existing) {
            if (cache && BaseManager_1.isPatchable(existing)) {
                existing.$patch(data);
            }
            return existing;
        }
        const entry = new this.hold(this.client, data);
        if (cache) {
            this.cache.set(entry.id, entry);
        }
        return entry;
    }
    /**
     * Fetch the payment by its id in the cache or from the Pi Network Platform API.
     *
     * @param id - The payment id to fetch.
     * @param cache - If the payment should be cached (or cached payment patched), `true` by default.
     * @param checkCache - If the payment should be fetched in the cache, `true` by default.
     * @returns - The fetched payment.
     */
    async fetch(id, cache, checkCache = true) {
        const existing = checkCache && this.cache.get(id);
        if (existing) {
            return existing;
        }
        const payment = await this.client.http.request('get', api_typing_1.getPayment({ paymentId: id }));
        return this.add(payment, cache);
    }
}
exports.PaymentManager = PaymentManager;
//# sourceMappingURL=PaymentManager.js.map