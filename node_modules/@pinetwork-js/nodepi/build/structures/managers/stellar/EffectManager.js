"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EffectManager = void 0;
const ressources_1 = require("../../ressources");
const BaseManager_1 = require("../BaseManager");
class EffectManager extends BaseManager_1.BaseManager {
    stellar;
    constructor(stellar, iterable) {
        super(stellar.client, ressources_1.Effect, iterable);
        this.stellar = stellar;
    }
    /**
     * Adds the effect to the cache (or return the cached effect, if `cache` is true).
     *
     * @param data - The effect to add.
     * @param cache - If the effect should be cached (or cached effect patched), `true` by default.
     * @returns The resolved effect.
     */
    add(data, cache = true) {
        const existing = this.cache.get(data.id);
        if (existing) {
            if (cache && BaseManager_1.isPatchable(existing)) {
                existing.$patch(data);
            }
            return existing;
        }
        let entry;
        // eslint-disable-next-line sonarjs/max-switch-cases
        switch (data.type) {
            case ressources_1.EffectTypeNames.accountCreated: {
                entry = new ressources_1.AccountCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountCredited: {
                entry = new ressources_1.AccountCreditedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountDebited: {
                entry = new ressources_1.AccountDebitedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountFlagsUpdated: {
                entry = new ressources_1.AccountFlagsUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountHomeDomainUpdated: {
                entry = new ressources_1.AccountHomeDomainUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountSponsorshipCreated: {
                entry = new ressources_1.AccountSponsorshipCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountSponsorshipRemoved: {
                entry = new ressources_1.AccountSponsorshipRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountSponsorshipUpdated: {
                entry = new ressources_1.AccountSponsorshipUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.accountThresholdsUpdated: {
                entry = new ressources_1.AccountThresholdsUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceClaimantCreated: {
                entry = new ressources_1.ClaimableBalanceClaimantCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceClaimed: {
                entry = new ressources_1.ClaimableBalanceClaimedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceCreated: {
                entry = new ressources_1.ClaimableBalanceCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceSponsorshipCreated: {
                entry = new ressources_1.ClaimableBalanceSponsorshipCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceSponsorshipRemoved: {
                entry = new ressources_1.ClaimableBalanceSponsorshipRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.claimableBalanceSponsorshipUpdated: {
                entry = new ressources_1.ClaimableBalanceSponsorshipUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataCreated: {
                entry = new ressources_1.DataCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataRemoved: {
                entry = new ressources_1.DataRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataSponsorshipCreated: {
                entry = new ressources_1.DataSponsorshipCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataSponsorshipRemoved: {
                entry = new ressources_1.DataSponsorshipRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataSponsorshipUpdated: {
                entry = new ressources_1.DataSponsorshipUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.dataUpdated: {
                entry = new ressources_1.DataUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.sequenceBumped: {
                entry = new ressources_1.SequenceBumpedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerCreated: {
                entry = new ressources_1.SignerCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerRemoved: {
                entry = new ressources_1.SignerRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerSponsorshipCreated: {
                entry = new ressources_1.SignerSponsorshipCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerSponsorshipRemoved: {
                entry = new ressources_1.SignerSponsorshipRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerSponsorshipUpdated: {
                entry = new ressources_1.SignerSponsorshipUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.signerUpdated: {
                entry = new ressources_1.SignerUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trade: {
                entry = new ressources_1.TradeEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineAuthorized: {
                entry = new ressources_1.TrustlineAuthorizedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineAuthorizedToMaintainLiabilities: {
                entry = new ressources_1.TrustlineAuthorizedToMaintainLiabilitiesEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineCreated: {
                entry = new ressources_1.TrustlineCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineDeauthorized: {
                entry = new ressources_1.TrustlineDeauthorizedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineFlagsUpdated: {
                entry = new ressources_1.TrustlineFlagsUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineRemoved: {
                entry = new ressources_1.TrustlineRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineSponsorshipCreated: {
                entry = new ressources_1.TrustlineSponsorshipCreatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineSponsorshipRemoved: {
                entry = new ressources_1.TrustlineSponsorshipRemovedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineSponsorshipUpdated: {
                entry = new ressources_1.TrustlineSponsorshipUpdatedEffect(this.client, data);
                break;
            }
            case ressources_1.EffectTypeNames.trustlineUpdated: {
                entry = new ressources_1.TrustlineUpdatedEffect(this.client, data);
                break;
            }
            default: {
                entry = new this.hold(this.client, data);
            }
        }
        if (cache) {
            this.cache.set(entry.id, entry);
        }
        return entry;
    }
    /**
     * Fetch the effect by its id in the cache or from the Pi Network Stellar API.
     *
     * @param id - The effect id to fetch.
     * @param cache - If the effect should be cached (or cached effect patched), `true` by default.
     * @param checkCache - If the effect should be fetched in the cache, `true` by default.
     * @returns The fetched effect.
     */
    async fetch(id, cache, checkCache = true) {
        const existing = checkCache && this.cache.get(id);
        if (existing) {
            return existing;
        }
        const [operationId, effectNumber] = id.split('-').map((part) => `${Number(part)}`);
        const operationEffects = await this.stellar.server.effects().forOperation(operationId).call();
        const effect = operationEffects.records[Number(effectNumber)];
        return this.add(effect, cache);
    }
}
exports.EffectManager = EffectManager;
//# sourceMappingURL=EffectManager.js.map