"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Payment = void 0;
const api_typing_1 = require("@pinetwork-js/api-typing");
/**
 * Structure representing a Pi Network Payment.
 */
class Payment {
    client;
    /**
     * The id of the payment.
     */
    id;
    /**
     * The amount of the payment.
     */
    amount;
    /**
     * A string provided by the developer, shown to the user.
     */
    memo;
    /**
     * An object provided by the developer for their own usage.
     */
    metadata;
    /**
     * The user's app-specific id.
     */
    userUid;
    /**
     * The recipient address of the blockchain transaction.
     */
    recipientAdresse;
    /**
     * The date when the payment was created.
     */
    createdAt;
    /**
     * The timestamp when the payment was created.
     */
    createdTimestamp;
    /**
     * The status flags representing the current state of the payment.
     */
    status;
    /**
     * The blockchain transaction data, this is null if no transaction has been made yet.
     */
    transactionInfo;
    constructor(client, data) {
        this.client = client;
        this.$patch(data);
    }
    $patch(data) {
        this.id = data.identifier;
        this.amount = data.amount;
        this.memo = data.memo;
        this.metadata = data.metadata;
        this.userUid = data.user_uid;
        this.recipientAdresse = data.to_address;
        this.createdAt = new Date(data.created_at);
        this.createdTimestamp = this.createdAt.getTime();
        this.status = {
            developerApproved: data.status.developer_approved,
            transactionVerified: data.status.transaction_verified,
            developerCompleted: data.status.developer_completed,
            cancelled: data.status.cancelled,
            userCancelled: data.status.user_cancelled,
        };
        if (data.transaction) {
            this.transactionInfo = {
                transactionId: data.transaction.txid,
                verified: data.transaction.verified,
            };
        }
    }
    /**
     * Whether or not the payment has been cancelled.
     */
    get cancelled() {
        return this.status.cancelled || this.status.userCancelled;
    }
    /**
     * Approve the payment.
     *
     * @returns The approved payment.
     */
    async approve() {
        const payment = await this.client.http.request('post', api_typing_1.routes.approvePayment({ paymentId: this.id }));
        return this.client.payments.add(payment);
    }
    /**
     * Complete the payment.
     *
     * @returns The completed payment.
     */
    async complete() {
        if (!this.transactionInfo) {
            return;
        }
        const payment = await this.client.http.request('post', api_typing_1.routes.completePayment({ paymentId: this.id }), {
            txid: this.transactionInfo.transactionId,
        });
        return this.client.payments.add(payment);
    }
    /**
     * Get the transaction of the payment if there is one.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the receiver transaction instead.
     * @returns The transaction of the payment if there is one.
     */
    async getTransaction(forceUpdate = false) {
        if (!this.transactionInfo) {
            return;
        }
        return this.client.stellar.transactions.fetch(this.transactionInfo.transactionId, true, !forceUpdate);
    }
}
exports.Payment = Payment;
//# sourceMappingURL=Payment.js.map