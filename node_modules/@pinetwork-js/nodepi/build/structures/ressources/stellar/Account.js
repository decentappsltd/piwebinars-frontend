"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const utils_1 = require("../../../utils");
const isApplicationEffect_1 = require("../../../utils/isApplicationEffect");
const isApplicationOffer_1 = require("../../../utils/isApplicationOffer");
const isApplicationTrade_1 = require("../../../utils/isApplicationTrade");
const managers_1 = require("../../managers");
const EffectManager_1 = require("../../managers/stellar/EffectManager");
/**
 * Structure representing a Stellar Account.
 */
class Account {
    client;
    /**
     * The id of the account.
     */
    id;
    /**
     * A cursor value for use in pagination.
     */
    pagingToken;
    /**
     * The account’s public key encoded in a base32 string representation.
     */
    accountPublicKey;
    /**
     * The account’s current sequence number. For use when submitting this account’s next transaction.
     */
    sequence;
    /**
     * The number of subentries on the account.
     */
    subentryCount;
    /**
     * The domain that hosts the account’s `stellar.toml` file.
     */
    homeDomain;
    /**
     * The id of the last ledger that included changes to the account.
     */
    lastModifiedLedgerId;
    /**
     * The number of reserves sponsored by the account.
     */
    numSponsoring;
    /**
     * The number of reserves sponsored for the account.
     */
    numSponsored;
    /**
     * The account id of the sponsor who is paying the reserves for the account.
     */
    sponsorId;
    /**
     * The thresholds for different access levels, as well as the weight of the master key.
     */
    thresholds;
    /**
     * Denote the enabling/disabling of certain asset issuer privileges.
     */
    flags;
    /**
     * The assets held by the account.
     */
    balances;
    /**
     * The public keys and associated weights that can be used to authorize transactions for this account. Used for multi-sig.
     */
    signers;
    /**
     * The account data.
     */
    data;
    /**
     * Get the operations of the account.
     */
    $operations;
    /**
     * Get the payment operations of the account.
     */
    $payments;
    /**
     * Get the offers of the account.
     */
    $offers;
    /**
     * Get the trades of the account.
     */
    $trades;
    /**
     * Get the data of the account.
     */
    $data;
    /**
     * Get the effects of the account.
     */
    $effects;
    constructor(client, data) {
        this.client = client;
        this.$patch(data);
    }
    $patch(data) {
        this.id = data.id;
        this.pagingToken = data.paging_token;
        this.accountPublicKey = data.account_id;
        this.sequence = data.sequence;
        this.subentryCount = data.subentry_count;
        this.homeDomain = data.home_domain;
        this.lastModifiedLedgerId = data.last_modified_ledger;
        this.numSponsoring = data.num_sponsoring;
        this.numSponsored = data.num_sponsored;
        this.sponsorId = data.sponsor;
        this.thresholds = {
            lowThreshold: data.thresholds.low_threshold,
            medThreshold: data.thresholds.med_threshold,
            highThreshold: data.thresholds.high_threshold,
        };
        this.flags = {
            authImmutable: data.flags.auth_immutable,
            authRequired: data.flags.auth_required,
            authRevocable: data.flags.auth_revocable,
        };
        this.balances = data.balances.map((balance) => {
            return balance.asset_type === 'native'
                ? {
                    balance: balance.balance,
                    assetType: balance.asset_type,
                    buyingLiabilities: balance.buying_liabilities,
                    sellingLiabilities: balance.selling_liabilities,
                }
                : {
                    balance: balance.balance,
                    limit: balance.limit,
                    assetType: balance.asset_type,
                    assetCode: balance.asset_code,
                    assetIssuerId: balance.asset_issuer,
                    buyingLiabilities: balance.buying_liabilities,
                    sellingLiabilities: balance.selling_liabilities,
                    lastModifiedLedger: balance.last_modified_ledger,
                    isAuthorized: balance.is_authorized,
                    isAuthorizedToMaintainLiabilities: balance.is_authorized_to_maintain_liabilities,
                    sponsor: balance.sponsor,
                };
        });
        this.signers = data.signers.map((signer) => ({ ...signer, type: signer.type }));
        this.data = data.data_attr;
        this.$operations = data.operations;
        this.$payments = data.payments;
        this.$offers = data.offers;
        this.$trades = data.trades;
        this.$data = data.data;
        this.$effects = data.effects;
    }
    /**
     * Get the operations of the account.
     *
     * @returns A manager for the account operations.
     */
    async getOperations() {
        const operations = (await this.$operations()).records;
        for (const operation of operations) {
            if (this.client.stellar.account && !utils_1.isApplicationOperation(operation, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.operations.add(operation);
        }
        return new managers_1.OperationManager(this.client.stellar, operations);
    }
    /**
     * Get the payment operations of the account.
     *
     * @returns A manager for the account payment operations.
     */
    async getPayments() {
        const payments = (await this.$payments()).records;
        for (const payment of payments) {
            if (this.client.stellar.account && !utils_1.isApplicationOperation(payment, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.operations.add(payment);
        }
        return new managers_1.OperationManager(this.client.stellar, payments);
    }
    /**
     * Get the offers of the account.
     *
     * @returns A manager for the account offers.
     */
    async getOffers() {
        const offers = (await this.$offers()).records;
        for (const offer of offers) {
            if (this.client.stellar.account && !isApplicationOffer_1.isApplicationOffer(offer, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.offers.add(offer);
        }
        return new managers_1.OfferManager(this.client.stellar, offers);
    }
    /**
     * Get the trades of the account.
     *
     * @returns A manager for the account trades.
     */
    async getTrades() {
        const trades = (await this.$trades()).records;
        for (const trade of trades) {
            if (this.client.stellar.account &&
                !(await isApplicationTrade_1.isApplicationTrade.call(this.client.stellar, trade, this.client.stellar.account.publicKey()))) {
                continue;
            }
            this.client.stellar.trades.add(trade);
        }
        return new managers_1.TradeManager(this.client.stellar, trades);
    }
    /**
     * Get the trasactions of the account.
     *
     * @returns A manager for the account transactions.
     */
    async getTransactions() {
        const transactions = (await this.client.stellar.server.transactions().forAccount(this.id).call()).records;
        for (const transaction of transactions) {
            if (this.client.stellar.account &&
                !(await utils_1.isApplicationTransaction(transaction, this.client.stellar.account.publicKey()))) {
                continue;
            }
            this.client.stellar.transactions.add(transaction);
        }
        return new managers_1.TransactionManager(this.client.stellar, transactions);
    }
    /**
     * Get the data entry of the account for the given key.
     *
     * @param key - The key of the data to retreive.
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the data entry instead.
     * @returns The data entry.
     */
    async getDataEntry(key, forceUpdate = false) {
        if (forceUpdate) {
            const data = await this.$data({ value: key });
            return { [key]: data.value };
        }
        return { [key]: this.data[key] };
    }
    /**
     * Get the sponsor of the account if there is one.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the sponsor account instead.
     * @returns The account of the sponsor if there is one.
     */
    async getSponsorAccount(forceUpdate = false) {
        if (!this.sponsorId) {
            return;
        }
        return this.client.stellar.accounts.fetch(this.sponsorId, true, !forceUpdate);
    }
    /**
     * Get the last ledger that included changes to the account.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the ledger instead.
     * @returns The last ledger that included changes to the account.
     */
    getLastModifiedLedger(forceUpdate = false) {
        return this.client.stellar.ledgers.fetch(this.lastModifiedLedgerId, true, !forceUpdate);
    }
    /**
     * Get the signers of the account.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the signer accounts instead.
     * @returns A manager for the account signers.
     */
    async getSigners(forceUpdate = false) {
        const signers = await Promise.all(this.signers.map((signer) => this.client.stellar.accounts.fetch(signer.key, true, !forceUpdate)));
        return new managers_1.AccountManager(this.client.stellar, signers);
    }
    /**
     * Get the non-native assets of the account balance.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the balance assets instead.
     * @returns A manager for the account balance assets.
     */
    async getBalanceAssets(forceUpdate = false) {
        const assets = await Promise.all(this.balances
            .filter((balance) => balance.assetType !== 'native')
            .map((balance) => {
            const assetId = `${balance.assetCode}:${balance.assetIssuerId}`;
            return this.client.stellar.assets.fetch(assetId, true, !forceUpdate);
        }));
        return new managers_1.AssetManager(this.client.stellar, assets);
    }
    /**
     * Get the effects of the account.
     *
     * @returns A manager for the account effects.
     */
    async getEffects() {
        const effects = (await this.$effects()).records;
        for (const effect of effects) {
            if (this.client.stellar.account && !isApplicationEffect_1.isApplicationEffect(effect, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.effects.add(effect);
        }
        return new EffectManager_1.EffectManager(this.client.stellar, effects);
    }
}
exports.Account = Account;
//# sourceMappingURL=Account.js.map