"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimableBalance = exports.deepPredicateChange = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
const camel_case_1 = require("camel-case");
const managers_1 = require("../../managers");
function deepPredicateChange(item) {
    if (Array.isArray(item)) {
        return item.map((deepItem) => deepPredicateChange(deepItem));
    }
    else {
        const keys = Object.keys(item);
        for (const key of keys) {
            if (key.includes('_')) {
                const value = item[key];
                const newKey = camel_case_1.camelCase(key);
                delete item[key];
                item[newKey] = newKey === 'absBefore' ? new Date(value) : value;
            }
        }
        return item;
    }
}
exports.deepPredicateChange = deepPredicateChange;
/**
 * Structure representing a Stellar Claimable Balance.
 */
class ClaimableBalance {
    client;
    /**
     * The id of the claimable balance.
     */
    id;
    /**
     * A cursor value for use in pagination.
     */
    pagingToken;
    /**
     * The asset available to be claimed in the SEP-11 form `asset_code:issuing_address` or `native` (for Pi).
     */
    assetInfo;
    /**
     * The amount of asset that can be claimed.
     */
    amount;
    /**
     * The account id of the sponsor who is paying the reserves for the claimable balance.
     */
    sponsorId;
    /**
     * The sequence number of the last ledger in which the claimable balance was modified.
     */
    lastModifiedLedgerId;
    /**
     * The date when the claimable balance was modified for the last time.
     */
    lastModifiedAt;
    /**
     * The timestamp when the claimable balance was modified for the last time.
     */
    lastModifiedTimestamp;
    /**
     * The list of entries which could claim the claimable balance.
     */
    claimants;
    constructor(client, data) {
        this.client = client;
        this.$patch(data);
    }
    $patch(data) {
        this.id = data.id;
        this.pagingToken = data.paging_token;
        this.assetInfo = data.asset;
        this.amount = Number(data.amount);
        this.sponsorId = data.sponsor;
        this.lastModifiedLedgerId = data.last_modified_ledger;
        this.lastModifiedAt = new Date(data.last_modified_time);
        this.claimants = data.claimants.map((claimant) => ({
            destination: claimant.destination,
            predicate: deepPredicateChange(claimant.predicate),
        }));
    }
    /**
     * Get the sponsor of the claimable balance if there is one.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the sponsor account instead.
     * @returns The account of the sponsor if there is one.
     */
    async getSponsor(forceUpdate = false) {
        if (!this.sponsorId) {
            return;
        }
        return this.client.stellar.accounts.fetch(this.sponsorId, true, !forceUpdate);
    }
    /**
     * Get the last ledger that included changes to the claimable balance.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the ledger instead.
     * @returns The last ledger that included changes to the claimable balance.
     */
    getLastModifiedLedger(forceUpdate = false) {
        return this.client.stellar.ledgers.fetch(this.lastModifiedLedgerId, true, !forceUpdate);
    }
    /**
     * Get the claimants account of the claimable balance.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the claimants account instead.
     * @returns A Map that contains claimants account mapped by their id.
     */
    async getClaimants(forceUpdate = false) {
        const claimants = await Promise.all(this.claimants.map((claimant) => this.client.stellar.accounts.fetch(claimant.destination, true, !forceUpdate)));
        return new managers_1.AccountManager(this.client.stellar, claimants);
    }
    /**
     * Get the asset of the claimable balance if it's not `native`.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the asset instead.
     * @returns The asset of the claimable balance if it's not `native`.
     */
    async getAsset(forceUpdate = false) {
        if (this.assetInfo === 'native') {
            return;
        }
        return this.client.stellar.assets.fetch(this.assetInfo, true, !forceUpdate);
    }
}
exports.ClaimableBalance = ClaimableBalance;
//# sourceMappingURL=ClaimableBalance.js.map