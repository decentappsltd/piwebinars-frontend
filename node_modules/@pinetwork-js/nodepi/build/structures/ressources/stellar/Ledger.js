"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ledger = void 0;
const utils_1 = require("../../../utils");
const isApplicationEffect_1 = require("../../../utils/isApplicationEffect");
const managers_1 = require("../../managers");
const EffectManager_1 = require("../../managers/stellar/EffectManager");
/**
 * Structure representing a Stellar Ledger.
 */
class Ledger {
    client;
    /**
     * The id of the ledger.
     */
    id;
    /**
     * A cursor value for use in pagination.
     */
    pagingToken;
    /**
     * A hex-encoded SHA-256 hash of the ledger’s XDR-encoded form.
     */
    hash;
    /**
     * The hash of the ledger immediately preceding the ledger.
     */
    previousHash;
    /**
     * The sequence number of the ledger, and the parameter used in Horizon calls that require a ledger number.
     */
    sequence;
    /**
     * The number of transactions in the ledger.
     */
    transactionCount;
    /**
     * The number of operations applied in the ledger.
     */
    operationCount;
    /**
     * The total number of operations in the ledger transaction set.
     */
    transactionSetOperationCount;
    /**
     * The date when the ledger was closed.
     */
    closedAt;
    /**
     * The timestamp when the ledger was closed.
     */
    closedTimestamp;
    /**
     * The total number of Pi in circulation.
     */
    totalCoins;
    /**
     * The sum of all transaction fees.
     */
    feePool;
    /**
     * The fee the network charges per operation in a transaction.
     */
    baseFeeInMicropi;
    /**
     * The reserve the network uses when calculating an account’s minimum balance.
     */
    baseReserveInMicropi;
    /**
     * The maximum number of operations validators have agreed to process in a given ledger. Since Protocol 11, ledger capacity has been measured in operations rather than transactions.
     */
    maxTransactionSetSize;
    /**
     * The protocol version that the Pi Network Stellar network was running when the ledger was committed.
     */
    protocolVersion;
    /**
     * A base64 encoded string of the raw LedgerHeader xdr struct for the ledger.
     */
    headerXdr;
    /**
     * Get the transactions of the ledger.
     */
    $transactions;
    /**
     * Get the operations of the ledger.
     */
    $operations;
    /**
     * Get the effects of the ledger.
     */
    $effects;
    constructor(client, data) {
        this.client = client;
        this.$patch(data);
    }
    $patch(data) {
        this.id = data.id;
        this.pagingToken = data.paging_token;
        this.hash = data.hash;
        this.previousHash = data.prev_hash;
        this.sequence = data.sequence;
        this.transactionCount = data.transaction_count;
        this.operationCount = data.operation_count;
        this.transactionSetOperationCount = data.tx_set_operation_count ?? undefined;
        this.closedAt = new Date(data.closed_at);
        this.closedTimestamp = this.closedAt.getTime();
        this.totalCoins = data.total_coins;
        this.feePool = data.fee_pool;
        this.baseFeeInMicropi = data.base_fee_in_stroops;
        this.baseReserveInMicropi = data.base_reserve_in_stroops;
        this.maxTransactionSetSize = data.max_tx_set_size;
        this.protocolVersion = data.protocol_version;
        this.headerXdr = data.header_xdr;
        this.$transactions = data.transactions;
        this.$operations = data.operations;
        this.$effects = data.effects;
    }
    /**
     * Get the transactions of the ledger.
     *
     * @returns A manager for the ledger transactions.
     */
    async getTransactions() {
        const transactions = (await this.$transactions()).records;
        for (const transaction of transactions) {
            if (this.client.stellar.account &&
                !(await utils_1.isApplicationTransaction(transaction, this.client.stellar.account.publicKey()))) {
                continue;
            }
            this.client.stellar.transactions.add(transaction);
        }
        return new managers_1.TransactionManager(this.client.stellar, transactions);
    }
    /**
     * Get the operations of the ledger.
     *
     * @returns A manager for the ledger operations.
     */
    async getOperations() {
        const operations = (await this.$operations()).records;
        for (const operation of operations) {
            if (this.client.stellar.account && !utils_1.isApplicationOperation(operation, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.operations.add(operation);
        }
        return new managers_1.OperationManager(this.client.stellar, operations);
    }
    /**
     * Get the effects of the ledger.
     *
     * @returns A manager for the ledger effects.
     */
    async getEffects() {
        const effects = (await this.$effects()).records;
        for (const effect of effects) {
            if (this.client.stellar.account && !isApplicationEffect_1.isApplicationEffect(effect, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.effects.add(effect);
        }
        return new EffectManager_1.EffectManager(this.client.stellar, effects);
    }
}
exports.Ledger = Ledger;
//# sourceMappingURL=Ledger.js.map