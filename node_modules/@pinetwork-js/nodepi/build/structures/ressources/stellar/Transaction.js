"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const isApplicationEffect_1 = require("../../../utils/isApplicationEffect");
const isApplicationOperation_1 = require("../../../utils/isApplicationOperation");
const managers_1 = require("../../managers");
const EffectManager_1 = require("../../managers/stellar/EffectManager");
/**
 * Structure representing a Stellar Transaction.
 */
class Transaction {
    client;
    /**
     * The id of the transaction.
     */
    id;
    /**
     * A cursor value for use in pagination.
     */
    pagingToken;
    /**
     * A hex-encoded SHA-256 hash of the transaction’s XDR-encoded form.
     */
    hash;
    /**
     * The sequence number of the ledger that the transaction was included in.
     */
    ledgerSequence;
    /**
     * The transaction creation date.
     */
    createdAt;
    /**
     * The transaction creation timestamp.
     */
    createdTimestamp;
    /**
     * The account that originates the transaction.
     */
    sourceAccountId;
    /**
     * The source account’s sequence number that the transaction consumed.
     */
    sourceAccountSequence;
    /**
     * The fee (in micropi) paid by the source account to apply this transaction to the ledger.
     */
    feeCharged;
    /**
     * The maximum fee (in micropi) that the source account was willing to pay.
     */
    maxFee;
    /**
     * The number of operations contained within the transaction.
     */
    operationCount;
    /**
     * A base64 encoded string of the raw TransactionEnvelope XDR struct for the transaction.
     */
    envelopeXdr;
    /**
     * A base64 encoded string of the raw TransactionResult XDR struct for the transaction.
     */
    resultXdr;
    /**
     * A base64 encoded string of the raw TransactionMeta XDR struct for the transaction.
     */
    resultMetaXdr;
    /**
     * A base64 encoded string of the raw LedgerEntryChanges XDR struct produced by taking fees for the transaction.
     */
    feeMetaXdr;
    /**
     * The memo attached to the transaction (the payment id of the transaction if made using Pi Network SDK).
     */
    _memo;
    /**
     * The type of memo. Potential values include `none`, `id`, `text`, `hash` and `return`.
     */
    memoType;
    /**
     * The signatures used to sign the transaction.
     */
    signatures;
    /**
     * Get the operations of the transaction.
     */
    $operations;
    /**
     * Get the effects of the transaction.
     */
    $effects;
    constructor(client, data) {
        this.client = client;
        this.$patch(data);
    }
    $patch(data) {
        this.id = data.id;
        this.pagingToken = data.paging_token;
        this.hash = data.hash;
        this.ledgerSequence = data.ledger_attr;
        this.createdAt = new Date(data.created_at);
        this.createdTimestamp = this.createdAt.getTime();
        this.sourceAccountId = data.source_account;
        this.sourceAccountSequence = data.source_account_sequence;
        this.feeCharged = data.fee_charged;
        this.maxFee = data.max_fee;
        this.operationCount = data.operation_count;
        this.envelopeXdr = data.envelope_xdr;
        this.resultXdr = data.result_xdr;
        this.resultMetaXdr = data.result_meta_xdr;
        this.feeMetaXdr = data.fee_meta_xdr;
        this._memo = data.memo;
        this.memoType = data.memo_type;
        this.signatures = data.signatures;
        this.$operations = data.operations;
        this.$effects = data.effects;
    }
    /**
     * The memo of the transaction. If the transaction was made using the Pi Network SDK, the memo is equal to the platform payment id, so it retrieve the platform payment, then the memo from it.
     */
    get memo() {
        if (!this._memo) {
            return;
        }
        const payment = this.client.payments.resolve(this._memo);
        return payment ? payment.memo : this._memo;
    }
    /**
     * Get the platform payment of the transaction if made using Pi Network SDK.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the platform payment instead.
     * @returns The platform payment of the transaction if made using Pi Network SDK.
     */
    async getPayment(forceUpdate = false) {
        if (!this._memo) {
            return;
        }
        const payment = this.client.payments.resolve(this._memo);
        return payment ? this.client.payments.fetch(this._memo, true, !forceUpdate) : undefined;
    }
    /**
     * Get the ledger the trasaction belongs to.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the ledger instead.
     * @returns The ledger the trasaction belongs to.
     */
    async getLedger(forceUpdate = false) {
        return this.client.stellar.ledgers.fetch(this.ledgerSequence, true, !forceUpdate);
    }
    /**
     * Get the operations of the transaction.
     *
     * @returns A manager for the transaction operations.
     */
    async getOperations() {
        const operations = (await this.$operations()).records;
        for (const operation of operations) {
            if (this.client.stellar.account && !isApplicationOperation_1.isApplicationOperation(operation, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.operations.add(operation);
        }
        return new managers_1.OperationManager(this.client.stellar, operations);
    }
    /**
     * Get the effects of the transaction.
     *
     * @returns A manager for the transaction effects.
     */
    async getEffects() {
        const effects = (await this.$effects()).records;
        for (const effect of effects) {
            if (this.client.stellar.account && !isApplicationEffect_1.isApplicationEffect(effect, this.client.stellar.account.publicKey())) {
                continue;
            }
            this.client.stellar.effects.add(effect);
        }
        return new EffectManager_1.EffectManager(this.client.stellar, effects);
    }
    /**
     * Get the source account of the transaction.
     *
     * @param forceUpdate - If set to `true`, it will not check in the cache and directly make a request to retrieve the source account instead.
     * @returns The source account of the transaction.
     */
    getSourceAccount(forceUpdate = false) {
        return this.client.stellar.accounts.fetch(this.sourceAccountId, true, !forceUpdate);
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=Transaction.js.map